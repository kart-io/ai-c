# 单元测试文档

AI-Commit TUI项目完整的测试策略和实施方案

## 1. 测试策略概述

### 1.1 测试目标
- 确保所有核心功能按预期工作
- 验证模块间的正确交互
- 保证代码质量和稳定性
- 支持重构和功能迭代
- 提供性能基准测试

### 1.2 测试类型
- **单元测试**: 测试单个函数和方法
- **集成测试**: 测试模块间交互
- **端到端测试**: 测试完整用户工作流
- **性能测试**: 测试响应时间和资源使用
- **快照测试**: 测试UI输出一致性

### 1.3 测试覆盖率目标
- 单元测试覆盖率: ≥ 85%
- 分支覆盖率: ≥ 80%
- 核心模块覆盖率: ≥ 95%
- 关键路径覆盖率: 100%

## 2. 测试框架和工具

### 2.1 测试依赖配置
```toml
[dev-dependencies]
# 基础测试框架
tokio-test = "0.4"
test-log = "0.2"

# 断言增强
assert_matches = "1.5"
predicates = "3.0"
pretty_assertions = "1.4"

# 快照测试
insta = "1.34"

# 属性测试
proptest = "1.4"
quickcheck = "1.0"

# Mock和模拟
mockito = "1.2"
wiremock = "0.5"
mock_instant = "0.3"

# Agent系统测试工具
mockall = "0.11"  # Mock框架，用于Agent测试
fake = "2.9"      # Agent行为模拟
crossbeam-channel = "0.5"  # Agent通信测试

# MCP协议测试工具
tungstenite = "0.20"  # WebSocket测试
jsonschema = "0.17"   # MCP协议验证

# 测试工具
tempfile = "3.8"
serial_test = "3.0"
rstest = "0.18"

# 性能测试
criterion = { version = "0.5", features = ["html_reports"] }
tokio-metrics = "0.3"  # Agent性能测试
```

## 3. 单元测试设计

### 3.1 应用状态模块测试 (app/state.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use tokio::sync::Mutex;

    #[test]
    fn test_app_state_initialization() {
        let state = AppState::new();

        assert_eq!(state.current_tab, TabState::Status);
        assert!(state.selected_file.is_none());
        assert!(state.modal_stack.is_empty());
        assert!(state.file_status.is_empty());
    }

    #[test]
    fn test_state_update_file_selection() {
        let mut state = AppState::new();
        let file_item = FileItem::new("test.rs", FileStatus::Modified);

        state.update_state(Action::SelectFile(file_item.clone()));

        assert_eq!(state.selected_file, Some(file_item));
    }

    #[test]
    fn test_state_tab_switching() {
        let mut state = AppState::new();

        state.update_state(Action::SwitchTab(TabState::History));

        assert_eq!(state.current_tab, TabState::History);
    }

    #[tokio::test]
    async fn test_state_manager_thread_safety() {
        let state_manager = Arc::new(Mutex::new(AppState::new()));
        let mut handles = vec![];

        for i in 0..10 {
            let state_clone = Arc::clone(&state_manager);
            let handle = tokio::spawn(async move {
                let mut state = state_clone.lock().await;
                state.update_state(Action::SelectFile(
                    FileItem::new(&format!("file_{}.rs", i), FileStatus::Added)
                ));
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.await.unwrap();
        }

        // 验证状态一致性
        let final_state = state_manager.lock().await;
        assert!(final_state.selected_file.is_some());
    }

    #[test]
    fn test_modal_stack_operations() {
        let mut state = AppState::new();
        let modal = Modal::Confirm("Test message".to_string());

        state.push_modal(modal.clone());
        assert_eq!(state.modal_stack.len(), 1);
        assert_eq!(state.current_modal(), Some(&modal));

        state.pop_modal();
        assert!(state.modal_stack.is_empty());
        assert!(state.current_modal().is_none());
    }
}
```

### 3.2 Git模块测试 (git/repository.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs;
    use std::process::Command;

    fn create_test_repo() -> (TempDir, GitService) {
        let temp_dir = TempDir::new().unwrap();
        let repo_path = temp_dir.path();

        // 初始化Git仓库
        Command::new("git")
            .args(&["init"])
            .current_dir(repo_path)
            .output()
            .expect("Failed to init git repo");

        // 配置Git用户
        Command::new("git")
            .args(&["config", "user.name", "Test User"])
            .current_dir(repo_path)
            .output()
            .unwrap();

        Command::new("git")
            .args(&["config", "user.email", "test@example.com"])
            .current_dir(repo_path)
            .output()
            .unwrap();

        let git_service = GitService::open_repository(repo_path).unwrap();
        (temp_dir, git_service)
    }

    #[test]
    fn test_repository_opening() {
        let (_temp_dir, git_service) = create_test_repo();
        assert!(git_service.is_valid_repository());
    }

    #[test]
    fn test_file_status_detection() {
        let (_temp_dir, git_service) = create_test_repo();
        let repo_path = git_service.get_workdir().unwrap();

        // 创建新文件
        fs::write(repo_path.join("test.txt"), "Hello, World!").unwrap();

        let status = git_service.get_status().unwrap();

        assert_eq!(status.len(), 1);
        assert_eq!(status[0].path, "test.txt");
        assert_eq!(status[0].status, FileStatus::Untracked);
    }

    #[test]
    fn test_file_staging() {
        let (_temp_dir, mut git_service) = create_test_repo();
        let repo_path = git_service.get_workdir().unwrap();

        // 创建并暂存文件
        fs::write(repo_path.join("staged.txt"), "Staged content").unwrap();
        git_service.stage_file("staged.txt").unwrap();

        let status = git_service.get_status().unwrap();
        let staged_file = status.iter()
            .find(|f| f.path == "staged.txt")
            .unwrap();

        assert_eq!(staged_file.status, FileStatus::Added);
    }

    #[test]
    fn test_commit_creation() {
        let (_temp_dir, mut git_service) = create_test_repo();
        let repo_path = git_service.get_workdir().unwrap();

        // 创建、暂存并提交文件
        fs::write(repo_path.join("commit_test.txt"), "Commit test").unwrap();
        git_service.stage_file("commit_test.txt").unwrap();

        let commit_id = git_service.commit("Initial commit").unwrap();

        assert!(!commit_id.is_zero());

        // 验证提交历史
        let history = git_service.get_commit_history(10).unwrap();
        assert_eq!(history.len(), 1);
        assert_eq!(history[0].message.trim(), "Initial commit");
    }

    #[test]
    fn test_diff_generation() {
        let (_temp_dir, mut git_service) = create_test_repo();
        let repo_path = git_service.get_workdir().unwrap();

        // 创建并修改文件
        fs::write(repo_path.join("diff_test.txt"), "Original content\n").unwrap();
        git_service.stage_file("diff_test.txt").unwrap();
        git_service.commit("Add original file").unwrap();

        fs::write(repo_path.join("diff_test.txt"), "Modified content\n").unwrap();

        let diff = git_service.get_diff("diff_test.txt").unwrap();

        assert!(diff.contains("Original content"));
        assert!(diff.contains("Modified content"));
        assert!(diff.contains("@@")); // diff头部标记
    }

    #[test]
    fn test_branch_operations() {
        let (_temp_dir, mut git_service) = create_test_repo();

        // 创建初始提交
        let repo_path = git_service.get_workdir().unwrap();
        fs::write(repo_path.join("initial.txt"), "Initial").unwrap();
        git_service.stage_file("initial.txt").unwrap();
        git_service.commit("Initial commit").unwrap();

        let branch_info = git_service.get_branch_info().unwrap();

        assert_eq!(branch_info.current_branch, "main");
        assert!(!branch_info.has_uncommitted_changes);
    }

    #[test]
    fn test_error_handling() {
        // 测试无效路径
        let result = GitService::open_repository(Path::new("/nonexistent/path"));
        assert!(result.is_err());

        // 测试操作不存在的文件
        let (_temp_dir, git_service) = create_test_repo();
        let result = git_service.get_diff("nonexistent.txt");
        assert!(result.is_err());
    }

    #[proptest]
    fn test_commit_message_validation(message in "\\PC{1,100}") {
        let (_temp_dir, mut git_service) = create_test_repo();
        let repo_path = git_service.get_workdir().unwrap();

        fs::write(repo_path.join("prop_test.txt"), "Property test").unwrap();
        git_service.stage_file("prop_test.txt").unwrap();

        if !message.trim().is_empty() {
            assert!(git_service.commit(&message).is_ok());
        }
    }
}
```

### 3.3 Git工作流管理模块测试 (git/workflow.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use std::fs;
    use std::process::Command;

    fn create_git_flow_repo() -> (TempDir, GitWorkflowManager) {
        let temp_dir = TempDir::new().unwrap();
        let repo_path = temp_dir.path();

        // 初始化Git仓库
        Command::new("git")
            .args(&["init"])
            .current_dir(repo_path)
            .output()
            .expect("Failed to init git repo");

        // 配置Git用户
        Command::new("git")
            .args(&["config", "user.name", "Test User"])
            .current_dir(repo_path)
            .output()
            .unwrap();

        Command::new("git")
            .args(&["config", "user.email", "test@example.com"])
            .current_dir(repo_path)
            .output()
            .unwrap();

        // 创建初始提交
        fs::write(repo_path.join("README.md"), "# Test Repository").unwrap();
        Command::new("git")
            .args(&["add", "README.md"])
            .current_dir(repo_path)
            .output()
            .unwrap();
        Command::new("git")
            .args(&["commit", "-m", "Initial commit"])
            .current_dir(repo_path)
            .output()
            .unwrap();

        let git_service = Arc::new(GitService::open_repository(repo_path).unwrap());
        let workflow_manager = GitWorkflowManager::new(git_service);
        (temp_dir, workflow_manager)
    }

    // 分支管理测试
    #[test]
    fn test_branch_creation_and_deletion() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建新分支
        workflow_manager.create_branch("feature/test-feature", None).unwrap();

        let branches = workflow_manager.list_branches(BranchFilter::All).unwrap();
        let feature_branch = branches.iter()
            .find(|b| b.name == "feature/test-feature")
            .unwrap();

        assert_eq!(feature_branch.name, "feature/test-feature");
        assert_eq!(feature_branch.branch_type, BranchType::Feature);

        // 删除分支
        workflow_manager.delete_branch("feature/test-feature", false).unwrap();

        let branches_after = workflow_manager.list_branches(BranchFilter::All).unwrap();
        assert!(!branches_after.iter().any(|b| b.name == "feature/test-feature"));
    }

    #[test]
    fn test_branch_switching() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建并切换到新分支
        workflow_manager.create_branch("develop", None).unwrap();
        workflow_manager.switch_branch("develop").unwrap();

        let branch_info = workflow_manager.get_current_branch_info().unwrap();
        assert_eq!(branch_info.current_branch, "develop");
    }

    #[test]
    fn test_branch_merge() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建feature分支
        workflow_manager.create_branch("feature/merge-test", None).unwrap();
        workflow_manager.switch_branch("feature/merge-test").unwrap();

        // 在feature分支上创建提交
        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("feature.txt"), "Feature content").unwrap();
        workflow_manager.git_service.stage_file("feature.txt").unwrap();
        workflow_manager.git_service.commit("Add feature").unwrap();

        // 切换回main并合并
        workflow_manager.switch_branch("main").unwrap();
        workflow_manager.merge_branch("feature/merge-test", "main",
                                      MergeStrategy::NoFastForward).unwrap();

        // 验证合并结果
        let history = workflow_manager.git_service.get_commit_history(5).unwrap();
        assert!(history.iter().any(|c| c.message.contains("Add feature")));
    }

    // 标签管理测试
    #[test]
    fn test_tag_creation_and_deletion() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建标签
        workflow_manager.create_tag("v1.0.0",
                                    Some("Release version 1.0.0"),
                                    None).unwrap();

        let tags = workflow_manager.list_tags().unwrap();
        let tag = tags.iter().find(|t| t.name == "v1.0.0").unwrap();

        assert_eq!(tag.name, "v1.0.0");
        assert_eq!(tag.message.as_ref().unwrap(), "Release version 1.0.0");

        // 删除标签
        workflow_manager.delete_tag("v1.0.0").unwrap();

        let tags_after = workflow_manager.list_tags().unwrap();
        assert!(!tags_after.iter().any(|t| t.name == "v1.0.0"));
    }

    #[test]
    fn test_semantic_versioning() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建几个语义化版本标签
        workflow_manager.create_tag("v0.1.0", None, None).unwrap();
        workflow_manager.create_tag("v0.2.0", None, None).unwrap();

        // 建议下一个版本号
        let next_patch = workflow_manager.tag_manager
            .suggest_next_version(ChangeType::Patch).unwrap();
        let next_minor = workflow_manager.tag_manager
            .suggest_next_version(ChangeType::Minor).unwrap();
        let next_major = workflow_manager.tag_manager
            .suggest_next_version(ChangeType::Major).unwrap();

        assert_eq!(next_patch, "v0.2.1");
        assert_eq!(next_minor, "v0.3.0");
        assert_eq!(next_major, "v1.0.0");
    }

    // Git Flow工作流测试
    #[test]
    fn test_git_flow_initialization() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        let git_flow_config = GitFlowConfig {
            master_branch: "main".to_string(),
            develop_branch: "develop".to_string(),
            feature_prefix: "feature/".to_string(),
            release_prefix: "release/".to_string(),
            hotfix_prefix: "hotfix/".to_string(),
            support_prefix: "support/".to_string(),
            version_tag_prefix: "v".to_string(),
        };

        workflow_manager.init_gitflow(git_flow_config).unwrap();

        // 验证develop分支是否创建
        let branches = workflow_manager.list_branches(BranchFilter::Local).unwrap();
        assert!(branches.iter().any(|b| b.name == "develop"));
    }

    #[test]
    fn test_feature_workflow() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 初始化Git Flow
        let git_flow_config = GitFlowConfig::default();
        workflow_manager.init_gitflow(git_flow_config).unwrap();

        // 开始feature
        workflow_manager.start_feature("user-auth").unwrap();

        let branch_info = workflow_manager.get_current_branch_info().unwrap();
        assert_eq!(branch_info.current_branch, "feature/user-auth");

        // 在feature分支上开发
        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("auth.rs"), "pub mod auth {}").unwrap();
        workflow_manager.git_service.stage_file("auth.rs").unwrap();
        workflow_manager.git_service.commit("Add authentication module").unwrap();

        // 完成feature
        workflow_manager.finish_feature("user-auth").unwrap();

        // 验证已切换回develop分支
        let branch_info = workflow_manager.get_current_branch_info().unwrap();
        assert_eq!(branch_info.current_branch, "develop");

        // 验证feature分支已删除
        let branches = workflow_manager.list_branches(BranchFilter::Local).unwrap();
        assert!(!branches.iter().any(|b| b.name == "feature/user-auth"));
    }

    #[test]
    fn test_release_workflow() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 初始化Git Flow
        let git_flow_config = GitFlowConfig::default();
        workflow_manager.init_gitflow(git_flow_config).unwrap();

        // 开始release
        workflow_manager.start_release("1.0.0").unwrap();

        let branch_info = workflow_manager.get_current_branch_info().unwrap();
        assert_eq!(branch_info.current_branch, "release/1.0.0");

        // 完成release
        workflow_manager.finish_release("1.0.0").unwrap();

        // 验证标签创建
        let tags = workflow_manager.list_tags().unwrap();
        assert!(tags.iter().any(|t| t.name == "v1.0.0"));
    }

    #[test]
    fn test_hotfix_workflow() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 初始化Git Flow
        let git_flow_config = GitFlowConfig::default();
        workflow_manager.init_gitflow(git_flow_config).unwrap();

        // 创建初始版本标签
        workflow_manager.create_tag("v1.0.0", None, None).unwrap();

        // 开始hotfix
        workflow_manager.start_hotfix("critical-bug", "1.0.1").unwrap();

        let branch_info = workflow_manager.get_current_branch_info().unwrap();
        assert_eq!(branch_info.current_branch, "hotfix/critical-bug");

        // 修复bug
        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("bugfix.txt"), "Bug fixed").unwrap();
        workflow_manager.git_service.stage_file("bugfix.txt").unwrap();
        workflow_manager.git_service.commit("Fix critical bug").unwrap();

        // 完成hotfix
        workflow_manager.finish_hotfix("critical-bug").unwrap();

        // 验证hotfix已合并到main和develop
        workflow_manager.switch_branch("main").unwrap();
        let main_history = workflow_manager.git_service.get_commit_history(5).unwrap();
        assert!(main_history.iter().any(|c| c.message.contains("Fix critical bug")));

        workflow_manager.switch_branch("develop").unwrap();
        let develop_history = workflow_manager.git_service.get_commit_history(5).unwrap();
        assert!(develop_history.iter().any(|c| c.message.contains("Fix critical bug")));
    }

    // 远程仓库管理测试
    #[test]
    fn test_remote_management() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 添加远程仓库
        workflow_manager.add_remote("origin", "https://github.com/test/repo.git").unwrap();

        let remotes = workflow_manager.list_remotes().unwrap();
        let origin = remotes.iter().find(|r| r.name == "origin").unwrap();

        assert_eq!(origin.name, "origin");
        assert_eq!(origin.url, "https://github.com/test/repo.git");

        // 删除远程仓库
        workflow_manager.remove_remote("origin").unwrap();

        let remotes_after = workflow_manager.list_remotes().unwrap();
        assert!(!remotes_after.iter().any(|r| r.name == "origin"));
    }

    // 高级Git操作测试
    #[test]
    fn test_stash_operations() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建未提交的更改
        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("work.txt"), "Work in progress").unwrap();

        // 保存到stash
        workflow_manager.stash_save(Some("Work in progress"), false).unwrap();

        // 验证工作目录干净
        let status = workflow_manager.git_service.get_status().unwrap();
        assert!(status.is_empty());

        // 恢复stash
        workflow_manager.stash_pop(None).unwrap();

        // 验证更改已恢复
        let content = fs::read_to_string(repo_path.join("work.txt")).unwrap();
        assert_eq!(content, "Work in progress");
    }

    #[test]
    fn test_cherry_pick() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建feature分支并提交
        workflow_manager.create_branch("feature/cherry-test", None).unwrap();
        workflow_manager.switch_branch("feature/cherry-test").unwrap();

        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("cherry.txt"), "Cherry picked change").unwrap();
        workflow_manager.git_service.stage_file("cherry.txt").unwrap();
        let commit_id = workflow_manager.git_service.commit("Add cherry picked change").unwrap();

        // 切换到main分支
        workflow_manager.switch_branch("main").unwrap();

        // Cherry-pick提交
        let commit_hash = format!("{}", commit_id);
        workflow_manager.cherry_pick(&commit_hash).unwrap();

        // 验证提交已被cherry-pick到main
        let history = workflow_manager.git_service.get_commit_history(5).unwrap();
        assert!(history.iter().any(|c| c.message.contains("Add cherry picked change")));
    }

    // 分支保护规则测试
    #[test]
    fn test_branch_protection() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        let protection_rule = BranchProtectionRule {
            branch_pattern: "main".to_string(),
            require_pull_request: true,
            require_status_checks: true,
            enforce_admins: false,
            required_reviewers: 2,
        };

        workflow_manager.branch_manager
            .add_protection_rule(protection_rule).unwrap();

        // 测试保护规则检查
        let result = workflow_manager.branch_manager
            .check_protection_rules("main", BranchOperation::DirectPush);

        assert!(result.is_err());
    }

    // 分支比较测试
    #[test]
    fn test_branch_comparison() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建develop分支并添加提交
        workflow_manager.create_branch("develop", None).unwrap();
        workflow_manager.switch_branch("develop").unwrap();

        let repo_path = workflow_manager.git_service.get_workdir().unwrap();
        fs::write(repo_path.join("develop.txt"), "Develop branch change").unwrap();
        workflow_manager.git_service.stage_file("develop.txt").unwrap();
        workflow_manager.git_service.commit("Add develop change").unwrap();

        // 比较main和develop分支
        let comparison = workflow_manager.branch_manager
            .compare_branches("main", "develop").unwrap();

        assert_eq!(comparison.ahead_by, 1);
        assert_eq!(comparison.behind_by, 0);
        assert_eq!(comparison.commits.len(), 1);
    }

    // 错误处理测试
    #[test]
    fn test_workflow_error_handling() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 测试删除不存在的分支
        let result = workflow_manager.delete_branch("nonexistent", false);
        assert!(result.is_err());

        // 测试切换到不存在的分支
        let result = workflow_manager.switch_branch("nonexistent");
        assert!(result.is_err());

        // 测试创建重复的标签
        workflow_manager.create_tag("v1.0.0", None, None).unwrap();
        let result = workflow_manager.create_tag("v1.0.0", None, None);
        assert!(result.is_err());
    }

    // 性能测试
    #[test]
    fn test_workflow_performance() {
        let (_temp_dir, workflow_manager) = create_git_flow_repo();

        // 创建大量分支测试性能
        let start = std::time::Instant::now();

        for i in 0..100 {
            let branch_name = format!("test-branch-{}", i);
            workflow_manager.create_branch(&branch_name, None).unwrap();
        }

        let creation_time = start.elapsed();
        assert!(creation_time.as_millis() < 5000); // 应该在5秒内完成

        // 测试分支列表性能
        let start = std::time::Instant::now();
        let branches = workflow_manager.list_branches(BranchFilter::All).unwrap();
        let list_time = start.elapsed();

        assert!(branches.len() >= 100);
        assert!(list_time.as_millis() < 1000); // 应该在1秒内完成
    }
}
```

### 3.4 AI模块测试 (ai/client.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockito::{mock, Matcher};
    use serde_json::json;

    #[tokio::test]
    async fn test_ai_suggestion_generation() {
        let _mock = mock("POST", "/v1/chat/completions")
            .with_status(200)
            .with_header("content-type", "application/json")
            .with_body(json!({
                "choices": [{
                    "message": {
                        "content": "feat: add new user authentication system\n\n- Implement JWT token validation\n- Add password encryption\n- Create user login endpoint"
                    }
                }]
            }).to_string())
            .create();

        let config = AIConfig {
            api_url: mockito::server_url(),
            api_key: "test-key".to_string(),
            model: "gpt-3.5-turbo".to_string(),
            max_tokens: 150,
            temperature: 0.7,
        };

        let ai_service = AIService::new(config);

        let changes = vec![
            FileChange {
                path: "auth.rs".to_string(),
                status: FileStatus::Added,
                additions: 50,
                deletions: 0,
            }
        ];

        let suggestions = ai_service
            .generate_commit_message(&changes)
            .await
            .unwrap();

        assert!(!suggestions.is_empty());
        assert!(suggestions[0].message.contains("authentication"));
    }

    #[tokio::test]
    async fn test_ai_service_error_handling() {
        let _mock = mock("POST", "/v1/chat/completions")
            .with_status(500)
            .create();

        let config = AIConfig {
            api_url: mockito::server_url(),
            api_key: "test-key".to_string(),
            model: "gpt-3.5-turbo".to_string(),
            max_tokens: 150,
            temperature: 0.7,
        };

        let ai_service = AIService::new(config);
        let changes = vec![];

        let result = ai_service.generate_commit_message(&changes).await;
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_suggestion_caching() {
        let _mock = mock("POST", "/v1/chat/completions")
            .with_status(200)
            .with_body(json!({
                "choices": [{
                    "message": {
                        "content": "test: add unit tests"
                    }
                }]
            }).to_string())
            .expect(1) // 只应该调用一次
            .create();

        let config = AIConfig {
            api_url: mockito::server_url(),
            api_key: "test-key".to_string(),
            model: "gpt-3.5-turbo".to_string(),
            max_tokens: 150,
            temperature: 0.7,
        };

        let mut ai_service = AIService::new(config);
        let changes = vec![
            FileChange {
                path: "test.rs".to_string(),
                status: FileStatus::Added,
                additions: 10,
                deletions: 0,
            }
        ];

        // 第一次调用
        let suggestions1 = ai_service
            .generate_commit_message(&changes)
            .await
            .unwrap();

        // 第二次调用 (应该从缓存获取)
        let suggestions2 = ai_service
            .generate_commit_message(&changes)
            .await
            .unwrap();

        assert_eq!(suggestions1, suggestions2);
    }

    #[test]
    fn test_suggestion_ranking() {
        let processor = SuggestionProcessor::new();

        let suggestions = vec![
            AISuggestion {
                message: "fix: resolve critical security vulnerability".to_string(),
                confidence: 0.9,
                category: CommitCategory::Fix,
            },
            AISuggestion {
                message: "feat: add new feature".to_string(),
                confidence: 0.7,
                category: CommitCategory::Feature,
            },
            AISuggestion {
                message: "docs: update readme".to_string(),
                confidence: 0.5,
                category: CommitCategory::Documentation,
            },
        ];

        let ranked = processor.rank_suggestions(suggestions);

        // 应该按置信度排序
        assert!(ranked[0].confidence >= ranked[1].confidence);
        assert!(ranked[1].confidence >= ranked[2].confidence);
    }
}
```

### 3.5 搜索模块测试 (search/engine.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashSet;

    #[test]
    fn test_search_engine_initialization() {
        let search_engine = SearchEngine::new();
        assert!(search_engine.is_ready());
    }

    #[test]
    fn test_file_name_search() {
        let mut search_engine = SearchEngine::new();

        // 添加测试文件
        search_engine.index_file("src/main.rs", "");
        search_engine.index_file("tests/test_main.rs", "");
        search_engine.index_file("docs/README.md", "");

        let results = search_engine.search_files("main").unwrap();

        assert_eq!(results.len(), 2);
        let paths: HashSet<_> = results.iter().map(|r| &r.path).collect();
        assert!(paths.contains(&"src/main.rs".to_string()));
        assert!(paths.contains(&"tests/test_main.rs".to_string()));
    }

    #[test]
    fn test_content_search() {
        let mut search_engine = SearchEngine::new();

        search_engine.index_file("file1.rs", "fn main() { println!(\"Hello\"); }");
        search_engine.index_file("file2.rs", "fn test() { assert!(true); }");

        let results = search_engine.search_content("println").unwrap();

        assert_eq!(results.len(), 1);
        assert_eq!(results[0].path, "file1.rs");
        assert!(results[0].matches[0].line_content.contains("println"));
    }

    #[test]
    fn test_regex_search() {
        let mut search_engine = SearchEngine::new();

        search_engine.index_file("test.rs", "let x = 42;\nlet y = 24;");

        let results = search_engine
            .search_content_regex(r"let \w+ = \d+")
            .unwrap();

        assert_eq!(results.len(), 1);
        assert_eq!(results[0].matches.len(), 2);
    }

    #[test]
    fn test_search_filters() {
        let mut search_engine = SearchEngine::new();

        // 添加不同类型的文件
        search_engine.index_file("src/main.rs", "rust code");
        search_engine.index_file("src/lib.js", "javascript code");
        search_engine.index_file("README.md", "documentation");

        let filter = FileTypeFilter::new(vec!["rs".to_string()]);
        let results = search_engine
            .search_files_with_filter("", &filter)
            .unwrap();

        assert_eq!(results.len(), 1);
        assert!(results[0].path.ends_with(".rs"));
    }

    #[test]
    fn test_search_highlighting() {
        let search_engine = SearchEngine::new();

        let content = "This is a test string with multiple test occurrences";
        let highlighted = search_engine.highlight_matches(content, "test");

        assert!(highlighted.contains("<mark>test</mark>"));
        // 应该有两个高亮的test
        assert_eq!(highlighted.matches("<mark>test</mark>").count(), 2);
    }

    #[test]
    fn test_search_performance() {
        let mut search_engine = SearchEngine::new();

        // 添加大量文件进行性能测试
        for i in 0..1000 {
            search_engine.index_file(
                &format!("file_{}.rs", i),
                &format!("fn function_{}() {{ /* code */ }}", i)
            );
        }

        let start = std::time::Instant::now();
        let results = search_engine.search_content("function").unwrap();
        let duration = start.elapsed();

        assert_eq!(results.len(), 1000);
        assert!(duration.as_millis() < 100); // 应该在100ms内完成
    }

    #[proptest]
    fn test_search_query_validation(query in "\\PC{1,50}") {
        let search_engine = SearchEngine::new();

        // 所有有效的查询字符串都应该能被处理
        let result = search_engine.search_files(&query);
        assert!(result.is_ok());
    }
}
```

### 3.6 Agent系统测试 (ai/agents/base_agent.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    use mockall::mock;
    use tokio::sync::mpsc;
    use std::time::Duration;

    mock! {
        TestAgent {}

        #[async_trait]
        impl Agent for TestAgent {
            fn name(&self) -> &str;
            fn capabilities(&self) -> Vec<AgentCapability>;
            async fn handle_task(&mut self, task: AgentTask) -> Result<AgentResult>;
            fn health_check(&self) -> HealthStatus;
            async fn shutdown(&mut self) -> Result<()>;
        }
    }

    #[tokio::test]
    async fn test_agent_lifecycle() {
        let mut mock_agent = MockTestAgent::new();

        mock_agent
            .expect_name()
            .returning(|| "test_agent");

        mock_agent
            .expect_capabilities()
            .returning(|| vec![AgentCapability::CommitMessageGeneration]);

        mock_agent
            .expect_health_check()
            .returning(|| HealthStatus::Healthy);

        assert_eq!(mock_agent.name(), "test_agent");
        assert_eq!(mock_agent.capabilities(), vec![AgentCapability::CommitMessageGeneration]);
        assert_eq!(mock_agent.health_check(), HealthStatus::Healthy);
    }

    #[tokio::test]
    async fn test_agent_task_handling() {
        let mut mock_agent = MockTestAgent::new();

        let test_task = AgentTask::GenerateCommitMessage(FileChanges::new(vec![]));
        let expected_result = AgentResult::CommitSuggestions(vec![
            CommitSuggestion::new("test: add unit tests".to_string(), 0.8)
        ]);

        mock_agent
            .expect_handle_task()
            .with(eq(test_task.clone()))
            .returning(move |_| Ok(expected_result.clone()));

        let result = mock_agent.handle_task(test_task).await;
        assert!(result.is_ok());

        if let AgentResult::CommitSuggestions(suggestions) = result.unwrap() {
            assert_eq!(suggestions.len(), 1);
            assert_eq!(suggestions[0].message, "test: add unit tests");
        } else {
            panic!("Expected CommitSuggestions result");
        }
    }

    #[tokio::test]
    async fn test_agent_manager_registration() {
        let mut agent_manager = AgentManager::new();
        let mock_agent = Box::new(MockTestAgent::new());

        let result = agent_manager.register_agent(mock_agent).await;
        assert!(result.is_ok());

        let agent_count = agent_manager.agent_count().await;
        assert_eq!(agent_count, 1);
    }

    #[tokio::test]
    async fn test_agent_message_bus() {
        let (tx, mut rx) = mpsc::unbounded_channel();
        let message_bus = MessageBus::new(tx);

        let test_message = AgentMessage::TaskAssignment {
            agent_id: "test_agent".to_string(),
            task: AgentTask::GenerateCommitMessage(FileChanges::new(vec![])),
        };

        message_bus.send_message(test_message.clone()).await.unwrap();

        let received_message = tokio::time::timeout(
            Duration::from_millis(100),
            rx.recv()
        ).await.unwrap().unwrap();

        assert_eq!(received_message, test_message);
    }

    #[tokio::test]
    async fn test_agent_concurrent_execution() {
        let mut agent_manager = AgentManager::new();

        // 注册多个Agent
        for i in 0..3 {
            let mut mock_agent = MockTestAgent::new();
            mock_agent
                .expect_name()
                .returning(move || Box::leak(format!("agent_{}", i).into_boxed_str()));

            agent_manager.register_agent(Box::new(mock_agent)).await.unwrap();
        }

        let tasks = vec![
            AgentTask::GenerateCommitMessage(FileChanges::new(vec![])),
            AgentTask::AnalyzeCode(CodeSnippet::new("fn test() {}".to_string())),
            AgentTask::ReviewPullRequest(PRData::new()),
        ];

        // 并发执行任务
        let handles = tasks.into_iter().map(|task| {
            let manager = agent_manager.clone();
            tokio::spawn(async move {
                manager.dispatch_task(task).await
            })
        }).collect::<Vec<_>>();

        // 等待所有任务完成
        for handle in handles {
            let result = handle.await.unwrap();
            assert!(result.is_ok());
        }
    }

    #[tokio::test]
    async fn test_agent_health_monitoring() {
        let mut agent_manager = AgentManager::new();
        let health_monitor = agent_manager.health_monitor();

        // 注册一个不健康的Agent
        let mut unhealthy_agent = MockTestAgent::new();
        unhealthy_agent
            .expect_name()
            .returning(|| "unhealthy_agent");
        unhealthy_agent
            .expect_health_check()
            .returning(|| HealthStatus::Unhealthy("Test failure".to_string()));

        agent_manager.register_agent(Box::new(unhealthy_agent)).await.unwrap();

        // 检查健康状态
        let health_report = health_monitor.get_health_report().await;
        assert_eq!(health_report.unhealthy_agents.len(), 1);
        assert_eq!(health_report.unhealthy_agents[0], "unhealthy_agent");
    }

    #[test]
    fn test_agent_capabilities() {
        let capabilities = vec![
            AgentCapability::CommitMessageGeneration,
            AgentCapability::CodeAnalysis,
            AgentCapability::CodeReview,
        ];

        assert!(capabilities.contains(&AgentCapability::CommitMessageGeneration));
        assert_eq!(capabilities.len(), 3);
    }

    #[tokio::test]
    async fn test_agent_shutdown() {
        let mut mock_agent = MockTestAgent::new();

        mock_agent
            .expect_shutdown()
            .returning(|| Ok(()));

        let result = mock_agent.shutdown().await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_agent_error_handling() {
        let mut mock_agent = MockTestAgent::new();

        mock_agent
            .expect_handle_task()
            .returning(|_| Err(AgentError::TaskProcessingFailed("Test error".to_string())));

        let task = AgentTask::GenerateCommitMessage(FileChanges::new(vec![]));
        let result = mock_agent.handle_task(task).await;

        assert!(result.is_err());
        if let Err(AgentError::TaskProcessingFailed(msg)) = result {
            assert_eq!(msg, "Test error");
        }
    }
}
```

### 3.7 MCP协议测试 (ai/mcp/protocol.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use tokio_tungstenite::tungstenite::Message;
    use wiremock::{MockServer, Mock, ResponseTemplate};
    use wiremock::matchers::{method, path, body_json};

    #[tokio::test]
    async fn test_mcp_request_serialization() {
        let request = MCPRequest {
            id: RequestId::Number(1),
            method: "initialize".to_string(),
            params: Some(json!({
                "protocolVersion": "2024-11-05",
                "capabilities": {
                    "resources": {},
                    "tools": {}
                },
                "clientInfo": {
                    "name": "ai-commit",
                    "version": "0.1.0"
                }
            })),
        };

        let serialized = serde_json::to_string(&request).unwrap();
        let deserialized: MCPRequest = serde_json::from_str(&serialized).unwrap();

        assert_eq!(request.id, deserialized.id);
        assert_eq!(request.method, deserialized.method);
    }

    #[tokio::test]
    async fn test_mcp_response_handling() {
        let response_json = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "result": {
                "protocolVersion": "2024-11-05",
                "capabilities": {
                    "resources": {},
                    "tools": {}
                },
                "serverInfo": {
                    "name": "test-server",
                    "version": "1.0.0"
                }
            }
        });

        let response: MCPResponse = serde_json::from_value(response_json).unwrap();

        assert_eq!(response.id, RequestId::Number(1));
        assert!(response.result.is_some());
        assert!(response.error.is_none());
    }

    #[tokio::test]
    async fn test_mcp_websocket_transport() {
        // 创建测试WebSocket连接
        let mock_server = MockServer::start().await;

        // 模拟WebSocket握手
        Mock::given(method("GET"))
            .and(path("/ws"))
            .respond_with(ResponseTemplate::new(101)
                .insert_header("upgrade", "websocket")
                .insert_header("connection", "Upgrade"))
            .mount(&mock_server)
            .await;

        let ws_url = format!("ws://127.0.0.1:{}/ws", mock_server.address().port());

        // 测试WebSocket传输
        let transport = WebSocketTransport::new(&ws_url).await;
        assert!(transport.is_ok());
    }

    #[tokio::test]
    async fn test_mcp_resource_management() {
        let mut resource_registry = ResourceRegistry::new();

        let resource = Resource {
            uri: "file:///test.txt".to_string(),
            name: "test.txt".to_string(),
            description: Some("Test file".to_string()),
            mime_type: Some("text/plain".to_string()),
        };

        resource_registry.register_resource(resource.clone()).await.unwrap();

        let retrieved = resource_registry.get_resource(&resource.uri).await.unwrap();
        assert_eq!(retrieved.name, "test.txt");
        assert_eq!(retrieved.uri, "file:///test.txt");
    }

    #[tokio::test]
    async fn test_mcp_tool_registration() {
        let mut tool_registry = ToolRegistry::new();

        let tool = Tool {
            name: "git_status".to_string(),
            description: "Get git repository status".to_string(),
            input_schema: json!({
                "type": "object",
                "properties": {
                    "path": {
                        "type": "string",
                        "description": "Repository path"
                    }
                },
                "required": ["path"]
            }),
            handler: Arc::new(TestToolHandler),
        };

        tool_registry.register_tool(tool.clone()).await.unwrap();

        let tools = tool_registry.list_tools().await;
        assert_eq!(tools.len(), 1);
        assert_eq!(tools[0].name, "git_status");
    }

    struct TestToolHandler;

    #[async_trait]
    impl ToolHandler for TestToolHandler {
        async fn execute(&self, args: serde_json::Value) -> Result<ToolResult> {
            Ok(ToolResult {
                content: json!({ "status": "success" }),
                is_error: false,
            })
        }
    }

    #[tokio::test]
    async fn test_mcp_tool_execution() {
        let handler = TestToolHandler;
        let args = json!({ "path": "/test/repo" });

        let result = handler.execute(args).await.unwrap();

        assert!(!result.is_error);
        assert_eq!(result.content["status"], "success");
    }

    #[tokio::test]
    async fn test_mcp_server_client_communication() {
        let mock_server = MockServer::start().await;

        // 模拟MCP服务器响应
        Mock::given(method("POST"))
            .and(path("/mcp"))
            .and(body_json(json!({
                "jsonrpc": "2.0",
                "id": 1,
                "method": "tools/list"
            })))
            .respond_with(ResponseTemplate::new(200)
                .set_body_json(json!({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "result": {
                        "tools": [{
                            "name": "test_tool",
                            "description": "Test tool",
                            "inputSchema": {
                                "type": "object",
                                "properties": {}
                            }
                        }]
                    }
                })))
            .mount(&mock_server)
            .await;

        let client_config = MCPClientConfig {
            server_uri: mock_server.uri(),
            transport_type: TransportType::Http,
        };

        let mut client = MCPClient::new(client_config).await.unwrap();
        let tools = client.list_tools().await.unwrap();

        assert_eq!(tools.len(), 1);
        assert_eq!(tools[0].name, "test_tool");
    }

    #[tokio::test]
    async fn test_mcp_error_handling() {
        let error_response = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "error": {
                "code": -32601,
                "message": "Method not found",
                "data": null
            }
        });

        let response: MCPResponse = serde_json::from_value(error_response).unwrap();

        assert!(response.result.is_none());
        assert!(response.error.is_some());

        let error = response.error.unwrap();
        assert_eq!(error.code, -32601);
        assert_eq!(error.message, "Method not found");
    }

    #[tokio::test]
    async fn test_mcp_protocol_validation() {
        // 测试无效的JSON-RPC请求
        let invalid_request = json!({
            "method": "test",
            // 缺少required字段 "jsonrpc" 和 "id"
        });

        let result: Result<MCPRequest, _> = serde_json::from_value(invalid_request);
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_mcp_concurrent_requests() {
        let mock_server = MockServer::start().await;

        Mock::given(method("POST"))
            .respond_with(ResponseTemplate::new(200)
                .set_body_json(json!({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "result": { "success": true }
                })))
            .mount(&mock_server)
            .await;

        let client_config = MCPClientConfig {
            server_uri: mock_server.uri(),
            transport_type: TransportType::Http,
        };

        let client = Arc::new(MCPClient::new(client_config).await.unwrap());

        // 发送多个并发请求
        let handles = (0..5).map(|i| {
            let client = Arc::clone(&client);
            tokio::spawn(async move {
                client.send_request(MCPRequest {
                    id: RequestId::Number(i),
                    method: "test".to_string(),
                    params: None,
                }).await
            })
        }).collect::<Vec<_>>();

        // 等待所有请求完成
        for handle in handles {
            let result = handle.await.unwrap();
            assert!(result.is_ok());
        }
    }
}
### 3.8 UI组件测试 (ui/components/file_list.rs)

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use ratatui::backend::TestBackend;
    use ratatui::Terminal;
    use ratatui::buffer::Buffer;

    fn create_test_terminal() -> Terminal<TestBackend> {
        let backend = TestBackend::new(80, 24);
        Terminal::new(backend).unwrap()
    }

    #[test]
    fn test_file_list_rendering() {
        let mut terminal = create_test_terminal();
        let mut file_list = FileListComponent::new();

        file_list.add_file(FileItem {
            path: "src/main.rs".to_string(),
            status: FileStatus::Modified,
            additions: 10,
            deletions: 5,
        });

        file_list.add_file(FileItem {
            path: "README.md".to_string(),
            status: FileStatus::Added,
            additions: 20,
            deletions: 0,
        });

        terminal.draw(|frame| {
            let area = frame.size();
            file_list.render(frame, area, &AppState::new());
        }).unwrap();

        let buffer = terminal.backend().buffer();

        // 验证文件名显示
        assert!(buffer_contains_text(buffer, "src/main.rs"));
        assert!(buffer_contains_text(buffer, "README.md"));

        // 验证状态指示
        assert!(buffer_contains_text(buffer, "M")); // Modified
        assert!(buffer_contains_text(buffer, "A")); // Added
    }

    #[test]
    fn test_file_list_selection() {
        let mut file_list = FileListComponent::new();

        file_list.add_file(FileItem {
            path: "file1.rs".to_string(),
            status: FileStatus::Modified,
            additions: 1,
            deletions: 0,
        });

        file_list.add_file(FileItem {
            path: "file2.rs".to_string(),
            status: FileStatus::Added,
            additions: 1,
            deletions: 0,
        });

        assert_eq!(file_list.selected_index(), 0);

        file_list.select_next();
        assert_eq!(file_list.selected_index(), 1);

        file_list.select_previous();
        assert_eq!(file_list.selected_index(), 0);
    }

    #[test]
    fn test_file_list_filtering() {
        let mut file_list = FileListComponent::new();

        file_list.add_file(FileItem {
            path: "src/main.rs".to_string(),
            status: FileStatus::Modified,
            additions: 1,
            deletions: 0,
        });

        file_list.add_file(FileItem {
            path: "tests/test.rs".to_string(),
            status: FileStatus::Added,
            additions: 1,
            deletions: 0,
        });

        // 应用过滤器只显示修改的文件
        file_list.apply_filter(|item| {
            matches!(item.status, FileStatus::Modified)
        });

        assert_eq!(file_list.visible_items().len(), 1);
        assert_eq!(file_list.visible_items()[0].path, "src/main.rs");
    }

    fn buffer_contains_text(buffer: &Buffer, text: &str) -> bool {
        for y in 0..buffer.area.height {
            for x in 0..buffer.area.width {
                let cell = buffer.get(x, y);
                if cell.symbol.contains(text) {
                    return true;
                }
            }
        }
        false
    }

    #[test]
    fn test_file_list_sorting() {
        let mut file_list = FileListComponent::new();

        file_list.add_file(FileItem {
            path: "z_file.rs".to_string(),
            status: FileStatus::Modified,
            additions: 1,
            deletions: 0,
        });

        file_list.add_file(FileItem {
            path: "a_file.rs".to_string(),
            status: FileStatus::Added,
            additions: 1,
            deletions: 0,
        });

        file_list.sort_by_name();

        assert_eq!(file_list.items[0].path, "a_file.rs");
        assert_eq!(file_list.items[1].path, "z_file.rs");
    }

    #[test]
    fn test_file_list_empty_state() {
        let mut terminal = create_test_terminal();
        let file_list = FileListComponent::new();

        terminal.draw(|frame| {
            let area = frame.size();
            file_list.render(frame, area, &AppState::new());
        }).unwrap();

        let buffer = terminal.backend().buffer();
        assert!(buffer_contains_text(buffer, "No files"));
    }
}
```

## 4. 集成测试设计

### 4.1 Git集成测试 (tests/integration/git_integration.rs)

```rust
use ai_commit::{GitService, AppState, Action};
use tempfile::TempDir;
use std::fs;
use std::process::Command;

#[tokio::test]
async fn test_complete_git_workflow() {
    let temp_dir = create_git_repo().await;
    let repo_path = temp_dir.path();
    let mut git_service = GitService::open_repository(repo_path).unwrap();

    // 1. 创建文件
    fs::write(repo_path.join("feature.rs"), "pub fn new_feature() {}").unwrap();

    // 2. 检查状态
    let status = git_service.get_status().unwrap();
    assert_eq!(status.len(), 1);
    assert_eq!(status[0].status, FileStatus::Untracked);

    // 3. 暂存文件
    git_service.stage_file("feature.rs").unwrap();

    let status = git_service.get_status().unwrap();
    assert_eq!(status[0].status, FileStatus::Added);

    // 4. 创建提交
    let commit_id = git_service.commit("feat: add new feature function").unwrap();
    assert!(!commit_id.is_zero());

    // 5. 验证提交历史
    let history = git_service.get_commit_history(5).unwrap();
    assert_eq!(history.len(), 1);
    assert!(history[0].message.contains("feat: add new feature"));
}
```

### 4.2 Git工作流集成测试 (tests/integration/git_workflow_integration.rs)

```rust
use ai_commit::{GitWorkflowManager, GitService, BranchFilter, GitFlowConfig,
               ChangeType, MergeStrategy, BranchProtectionRule, BranchOperation};
use tempfile::TempDir;
use std::fs;
use std::process::Command;
use std::sync::Arc;

fn create_integration_repo() -> (TempDir, GitWorkflowManager) {
    let temp_dir = TempDir::new().unwrap();
    let repo_path = temp_dir.path();

    // 创建一个更复杂的Git仓库用于集成测试
    Command::new("git").args(&["init"]).current_dir(repo_path).output().unwrap();
    Command::new("git").args(&["config", "user.name", "Integration Test"])
        .current_dir(repo_path).output().unwrap();
    Command::new("git").args(&["config", "user.email", "test@integration.com"])
        .current_dir(repo_path).output().unwrap();

    // 创建多个初始文件和提交
    for i in 1..=3 {
        fs::write(repo_path.join(format!("file_{}.txt", i)),
                  format!("Initial content {}", i)).unwrap();
        Command::new("git").args(&["add", &format!("file_{}.txt", i)])
            .current_dir(repo_path).output().unwrap();
        Command::new("git").args(&["commit", "-m", &format!("Add file {}", i)])
            .current_dir(repo_path).output().unwrap();
    }

    let git_service = Arc::new(GitService::open_repository(repo_path).unwrap());
    let workflow_manager = GitWorkflowManager::new(git_service);
    (temp_dir, workflow_manager)
}

#[tokio::test]
async fn test_complete_git_flow_workflow() {
    let (_temp_dir, workflow_manager) = create_integration_repo();

    // 1. 初始化Git Flow
    let git_flow_config = GitFlowConfig::default();
    workflow_manager.init_gitflow(git_flow_config).unwrap();

    // 2. 完整的feature开发流程
    workflow_manager.start_feature("user-management").unwrap();

    // 在feature分支上进行多次提交
    let repo_path = workflow_manager.git_service.get_workdir().unwrap();

    // 第一次提交：添加用户模型
    fs::write(repo_path.join("user.rs"), "pub struct User { id: u64, name: String }").unwrap();
    workflow_manager.git_service.stage_file("user.rs").unwrap();
    workflow_manager.git_service.commit("Add User struct").unwrap();

    // 第二次提交：添加用户服务
    fs::write(repo_path.join("user_service.rs"), "impl UserService { pub fn create_user() {} }").unwrap();
    workflow_manager.git_service.stage_file("user_service.rs").unwrap();
    workflow_manager.git_service.commit("Add UserService").unwrap();

    // 3. 完成feature开发
    workflow_manager.finish_feature("user-management").unwrap();

    // 验证feature已合并到develop
    let current_branch = workflow_manager.get_current_branch_info().unwrap();
    assert_eq!(current_branch.current_branch, "develop");

    let history = workflow_manager.git_service.get_commit_history(10).unwrap();
    assert!(history.iter().any(|c| c.message.contains("Add User struct")));
    assert!(history.iter().any(|c| c.message.contains("Add UserService")));

    // 4. 创建release分支
    workflow_manager.start_release("1.0.0").unwrap();

    // 在release分支上进行版本准备工作
    fs::write(repo_path.join("VERSION"), "1.0.0").unwrap();
    workflow_manager.git_service.stage_file("VERSION").unwrap();
    workflow_manager.git_service.commit("Bump version to 1.0.0").unwrap();

    // 5. 完成release
    workflow_manager.finish_release("1.0.0").unwrap();

    // 验证release结果
    let tags = workflow_manager.list_tags().unwrap();
    assert!(tags.iter().any(|t| t.name == "v1.0.0"));

    // 验证main分支包含所有更改
    workflow_manager.switch_branch("main").unwrap();
    let main_history = workflow_manager.git_service.get_commit_history(15).unwrap();
    assert!(main_history.iter().any(|c| c.message.contains("Add User struct")));

    // 6. 模拟生产环境发现的紧急bug
    workflow_manager.start_hotfix("critical-security-fix", "1.0.1").unwrap();

    // 修复安全问题
    fs::write(repo_path.join("security_fix.rs"), "pub fn validate_input(input: &str) -> bool { !input.is_empty() }").unwrap();
    workflow_manager.git_service.stage_file("security_fix.rs").unwrap();
    workflow_manager.git_service.commit("Fix security vulnerability").unwrap();

    // 7. 完成hotfix
    workflow_manager.finish_hotfix("critical-security-fix").unwrap();

    // 验证hotfix已应用到main和develop
    workflow_manager.switch_branch("main").unwrap();
    let main_files = fs::read_dir(repo_path).unwrap()
        .map(|e| e.unwrap().file_name().to_string_lossy().to_string())
        .collect::<Vec<_>>();
    assert!(main_files.contains(&"security_fix.rs".to_string()));

    workflow_manager.switch_branch("develop").unwrap();
    let develop_files = fs::read_dir(repo_path).unwrap()
        .map(|e| e.unwrap().file_name().to_string_lossy().to_string())
        .collect::<Vec<_>>();
    assert!(develop_files.contains(&"security_fix.rs".to_string()));

    // 验证标签创建
    let final_tags = workflow_manager.list_tags().unwrap();
    assert!(final_tags.iter().any(|t| t.name == "v1.0.1"));
}

#[tokio::test]
async fn test_branch_protection_integration() {
    let (_temp_dir, workflow_manager) = create_integration_repo();

    // 设置分支保护规则
    let protection_rule = BranchProtectionRule {
        branch_pattern: "main".to_string(),
        require_pull_request: true,
        require_status_checks: true,
        enforce_admins: false,
        required_reviewers: 2,
    };

    workflow_manager.branch_manager
        .add_protection_rule(protection_rule).unwrap();

    // 尝试直接推送到受保护分支应该失败
    let result = workflow_manager.branch_manager
        .check_protection_rules("main", BranchOperation::DirectPush);
    assert!(result.is_err());

    // Pull Request操作应该被允许
    let result = workflow_manager.branch_manager
        .check_protection_rules("main", BranchOperation::PullRequest);
    assert!(result.is_ok());
}

#[tokio::test]
async fn test_semantic_versioning_integration() {
    let (_temp_dir, workflow_manager) = create_integration_repo();

    // 创建一系列语义化版本
    let versions = vec!["0.1.0", "0.2.0", "0.2.1", "1.0.0", "1.0.1", "1.1.0"];

    for version in versions {
        workflow_manager.create_tag(&format!("v{}", version),
                                    Some(&format!("Release {}", version)),
                                    None).unwrap();
    }

    // 测试版本建议功能
    let next_patch = workflow_manager.tag_manager
        .suggest_next_version(ChangeType::Patch).unwrap();
    let next_minor = workflow_manager.tag_manager
        .suggest_next_version(ChangeType::Minor).unwrap();
    let next_major = workflow_manager.tag_manager
        .suggest_next_version(ChangeType::Major).unwrap();

    assert_eq!(next_patch, "v1.1.1");
    assert_eq!(next_minor, "v1.2.0");
    assert_eq!(next_major, "v2.0.0");

    // 测试变更日志生成
    let changelog = workflow_manager.tag_manager
        .get_tag_changelog("v1.0.0", "v1.1.0").unwrap();
    assert!(!changelog.is_empty());
}

#[tokio::test]
async fn test_concurrent_branch_operations() {
    let (_temp_dir, workflow_manager) = create_integration_repo();

    // 并发创建多个分支
    let branch_names: Vec<String> = (0..10)
        .map(|i| format!("concurrent-branch-{}", i))
        .collect();

    let handles = branch_names.iter().map(|name| {
        let workflow_manager = workflow_manager.clone();
        let branch_name = name.clone();
        tokio::spawn(async move {
            workflow_manager.create_branch(&branch_name, None)
        })
    }).collect::<Vec<_>>();

    // 等待所有分支创建完成
    for handle in handles {
        let result = handle.await.unwrap();
        assert!(result.is_ok());
    }

    // 验证所有分支都已创建
    let branches = workflow_manager.list_branches(BranchFilter::Local).unwrap();
    for branch_name in &branch_names {
        assert!(branches.iter().any(|b| &b.name == branch_name));
    }

    // 并发删除所有分支
    let delete_handles = branch_names.iter().map(|name| {
        let workflow_manager = workflow_manager.clone();
        let branch_name = name.clone();
        tokio::spawn(async move {
            workflow_manager.delete_branch(&branch_name, false)
        })
    }).collect::<Vec<_>>();

    // 等待所有分支删除完成
    for handle in delete_handles {
        let result = handle.await.unwrap();
        assert!(result.is_ok());
    }

    // 验证所有分支都已删除
    let final_branches = workflow_manager.list_branches(BranchFilter::Local).unwrap();
    for branch_name in &branch_names {
        assert!(!final_branches.iter().any(|b| &b.name == branch_name));
    }
}

#[tokio::test]
async fn test_workflow_error_recovery() {
    let (_temp_dir, workflow_manager) = create_integration_repo();

    // 初始化Git Flow
    let git_flow_config = GitFlowConfig::default();
    workflow_manager.init_gitflow(git_flow_config).unwrap();

    // 开始一个feature
    workflow_manager.start_feature("test-feature").unwrap();

    // 在feature分支上创建冲突的更改
    let repo_path = workflow_manager.git_service.get_workdir().unwrap();
    fs::write(repo_path.join("conflict.txt"), "Feature version").unwrap();
    workflow_manager.git_service.stage_file("conflict.txt").unwrap();
    workflow_manager.git_service.commit("Add conflict file from feature").unwrap();

    // 切换到develop分支并创建冲突的更改
    workflow_manager.switch_branch("develop").unwrap();
    fs::write(repo_path.join("conflict.txt"), "Develop version").unwrap();
    workflow_manager.git_service.stage_file("conflict.txt").unwrap();
    workflow_manager.git_service.commit("Add conflict file from develop").unwrap();

    // 尝试完成feature（应该检测到冲突）
    let result = workflow_manager.finish_feature("test-feature");

    // 验证错误处理
    match result {
        Err(e) => {
            // 应该返回合并冲突错误
            assert!(e.to_string().contains("conflict") || e.to_string().contains("merge"));
        },
        Ok(_) => panic!("Expected merge conflict error"),
    }

    // 验证工作流状态保持一致
    let current_branch = workflow_manager.get_current_branch_info().unwrap();
    assert_eq!(current_branch.current_branch, "develop");

    // 验证feature分支仍然存在
    let branches = workflow_manager.list_branches(BranchFilter::Local).unwrap();
    assert!(branches.iter().any(|b| b.name == "feature/test-feature"));
}
```

### 4.4 Agent系统集成测试 (tests/integration/agent_integration.rs)

```rust
use ai_commit::{AgentManager, AgentTask, FileChanges, CommitAgent, AnalysisAgent};
use tokio::time::{timeout, Duration};
use std::sync::Arc;

#[tokio::test]
async fn test_multi_agent_collaboration() {
    let mut agent_manager = AgentManager::new();

    // 注册多个Agent
    let commit_agent = CommitAgent::new(AIConfig::test_config()).await.unwrap();
    let analysis_agent = AnalysisAgent::new().await.unwrap();

    agent_manager.register_agent(Box::new(commit_agent)).await.unwrap();
    agent_manager.register_agent(Box::new(analysis_agent)).await.unwrap();

    // 创建测试任务
    let file_changes = FileChanges::new(vec![
        FileChange {
            path: "src/main.rs".to_string(),
            status: FileStatus::Modified,
            additions: 20,
            deletions: 5,
        }
    ]);

    // 首先进行代码分析
    let analysis_task = AgentTask::AnalyzeCode(CodeSnippet::from_changes(&file_changes));
    let analysis_result = agent_manager.dispatch_task(analysis_task).await.unwrap();

    // 然后生成提交消息
    let commit_task = AgentTask::GenerateCommitMessage(file_changes);
    let commit_result = agent_manager.dispatch_task(commit_task).await.unwrap();

    // 验证结果
    assert!(matches!(analysis_result, AgentResult::CodeAnalysis(_)));
    assert!(matches!(commit_result, AgentResult::CommitSuggestions(_)));
}

#[tokio::test]
async fn test_agent_fault_tolerance() {
    let mut agent_manager = AgentManager::new();

    // 注册一个会失败的Agent
    let faulty_agent = FaultyTestAgent::new();
    agent_manager.register_agent(Box::new(faulty_agent)).await.unwrap();

    // 注册一个正常的Agent作为备用
    let backup_agent = CommitAgent::new(AIConfig::test_config()).await.unwrap();
    agent_manager.register_agent(Box::new(backup_agent)).await.unwrap();

    let task = AgentTask::GenerateCommitMessage(FileChanges::new(vec![]));

    // Agent管理器应该能够处理失败并重试或使用备用Agent
    let result = timeout(Duration::from_secs(10),
                         agent_manager.dispatch_task_with_retry(task, 3)).await;

    assert!(result.is_ok());
    let agent_result = result.unwrap().unwrap();
    assert!(matches!(agent_result, AgentResult::CommitSuggestions(_)));
}

#[tokio::test]
async fn test_agent_load_balancing() {
    let mut agent_manager = AgentManager::new();

    // 注册多个相同类型的Agent
    for i in 0..3 {
        let agent = CommitAgent::new(AIConfig::test_config()).await.unwrap();
        agent_manager.register_agent(Box::new(agent)).await.unwrap();
    }

    // 发送多个任务，应该被分配到不同的Agent
    let tasks = (0..9).map(|_| {
        AgentTask::GenerateCommitMessage(FileChanges::new(vec![]))
    }).collect::<Vec<_>>();

    let handles = tasks.into_iter().map(|task| {
        let manager = agent_manager.clone();
        tokio::spawn(async move {
            manager.dispatch_task(task).await
        })
    }).collect::<Vec<_>>();

    // 等待所有任务完成
    for handle in handles {
        let result = handle.await.unwrap();
        assert!(result.is_ok());
    }

    // 验证负载分布
    let metrics = agent_manager.get_load_metrics().await;
    assert!(metrics.tasks_distributed > 0);
    assert!(metrics.agents_utilized >= 2); // 至少使用了2个Agent
}

struct FaultyTestAgent;

#[async_trait]
impl Agent for FaultyTestAgent {
    fn name(&self) -> &str {
        "faulty_agent"
    }

    fn capabilities(&self) -> Vec<AgentCapability> {
        vec![AgentCapability::CommitMessageGeneration]
    }

    async fn handle_task(&mut self, _task: AgentTask) -> Result<AgentResult> {
        Err(AgentError::TaskProcessingFailed("Simulated failure".to_string()))
    }

    fn health_check(&self) -> HealthStatus {
        HealthStatus::Unhealthy("Always fails".to_string())
    }

    async fn shutdown(&mut self) -> Result<()> {
        Ok(())
    }
}
```

### 4.5 MCP协议集成测试 (tests/integration/mcp_integration.rs)

```rust
use ai_commit::{MCPServer, MCPClient, Tool, Resource, TransportType};
use serde_json::json;
use tokio::time::{timeout, Duration};
use std::sync::Arc;

#[tokio::test]
async fn test_mcp_full_workflow() {
    // 启动MCP服务器
    let mut server = MCPServer::new(MCPServerConfig {
        port: 0, // 使用随机端口
        transport: TransportType::Http,
    }).await.unwrap();

    // 注册资源
    let test_resource = Resource {
        uri: "git://repo/status".to_string(),
        name: "Git Status".to_string(),
        description: Some("Current repository status".to_string()),
        mime_type: Some("application/json".to_string()),
    };

    server.register_resource(test_resource).await.unwrap();

    // 注册工具
    let git_tool = Tool {
        name: "git_commit".to_string(),
        description: "Create a git commit".to_string(),
        input_schema: json!({
            "type": "object",
            "properties": {
                "message": {"type": "string"},
                "files": {"type": "array", "items": {"type": "string"}}
            },
            "required": ["message"]
        }),
        handler: Arc::new(GitCommitHandler),
    };

    server.register_tool(git_tool).await.unwrap();

    // 启动服务器
    let server_addr = server.start().await.unwrap();

    // 创建客户端
    let client_config = MCPClientConfig {
        server_uri: format!("http://{}", server_addr),
        transport_type: TransportType::Http,
    };

    let mut client = MCPClient::new(client_config).await.unwrap();

    // 测试资源访问
    let resources = client.list_resources().await.unwrap();
    assert_eq!(resources.len(), 1);
    assert_eq!(resources[0].name, "Git Status");

    // 测试工具调用
    let tools = client.list_tools().await.unwrap();
    assert_eq!(tools.len(), 1);
    assert_eq!(tools[0].name, "git_commit");

    let tool_result = client.call_tool("git_commit", json!({
        "message": "test: add integration test",
        "files": ["test.rs"]
    })).await.unwrap();

    assert!(!tool_result.is_error);
    assert_eq!(tool_result.content["status"], "success");

    // 清理
    server.shutdown().await.unwrap();
}

struct GitCommitHandler;

#[async_trait]
impl ToolHandler for GitCommitHandler {
    async fn execute(&self, args: serde_json::Value) -> Result<ToolResult> {
        let message = args["message"].as_str()
            .ok_or_else(|| ToolError::InvalidArguments("Missing message".to_string()))?;

        // 模拟git commit操作
        tokio::time::sleep(Duration::from_millis(100)).await;

        Ok(ToolResult {
            content: json!({
                "status": "success",
                "commit_message": message,
                "commit_id": "abc123"
            }),
            is_error: false,
        })
    }
}

#[tokio::test]
async fn test_mcp_websocket_transport() {
    // 启动WebSocket MCP服务器
    let mut server = MCPServer::new(MCPServerConfig {
        port: 0,
        transport: TransportType::WebSocket,
    }).await.unwrap();

    let server_addr = server.start().await.unwrap();

    // WebSocket客户端连接
    let client_config = MCPClientConfig {
        server_uri: format!("ws://{}/mcp", server_addr),
        transport_type: TransportType::WebSocket,
    };

    let mut client = MCPClient::new(client_config).await.unwrap();

    // 测试实时通信
    let ping_result = client.ping().await.unwrap();
    assert_eq!(ping_result.latency_ms, 0..100); // 应该很快

    server.shutdown().await.unwrap();
}

#[tokio::test]
async fn test_mcp_concurrent_clients() {
    let mut server = MCPServer::new(MCPServerConfig {
        port: 0,
        transport: TransportType::Http,
    }).await.unwrap();

    let server_addr = server.start().await.unwrap();

    // 创建多个并发客户端
    let client_handles = (0..5).map(|i| {
        let server_uri = format!("http://{}", server_addr);
        tokio::spawn(async move {
            let client_config = MCPClientConfig {
                server_uri,
                transport_type: TransportType::Http,
            };

            let mut client = MCPClient::new(client_config).await.unwrap();

            // 每个客户端发送多个请求
            for j in 0..10 {
                let response = client.send_request(MCPRequest {
                    id: RequestId::Number((i * 10 + j) as i64),
                    method: "ping".to_string(),
                    params: None,
                }).await;

                assert!(response.is_ok());
            }
        })
    }).collect::<Vec<_>>();

    // 等待所有客户端完成
    for handle in client_handles {
        handle.await.unwrap();
    }

    server.shutdown().await.unwrap();
}

#[tokio::test]
async fn test_mcp_protocol_error_handling() {
    let mut server = MCPServer::new(MCPServerConfig {
        port: 0,
        transport: TransportType::Http,
    }).await.unwrap();

    let server_addr = server.start().await.unwrap();

    let client_config = MCPClientConfig {
        server_uri: format!("http://{}", server_addr),
        transport_type: TransportType::Http,
    };

    let mut client = MCPClient::new(client_config).await.unwrap();

    // 测试无效方法调用
    let response = client.send_request(MCPRequest {
        id: RequestId::Number(1),
        method: "nonexistent_method".to_string(),
        params: None,
    }).await.unwrap();

    assert!(response.error.is_some());
    let error = response.error.unwrap();
    assert_eq!(error.code, -32601); // Method not found

    server.shutdown().await.unwrap();
}
### 4.6 AI集成测试 (tests/integration/ai_integration.rs)

```rust
use ai_commit::{AIService, FileChange, FileStatus};
use wiremock::{MockServer, Mock, ResponseTemplate};
use wiremock::matchers::{method, path};

#[tokio::test]
async fn test_ai_service_integration() {
    let mock_server = MockServer::start().await;

    Mock::given(method("POST"))
        .and(path("/v1/chat/completions"))
        .respond_with(ResponseTemplate::new(200)
            .set_body_json(serde_json::json!({
                "choices": [{
                    "message": {
                        "content": "feat: implement user authentication\n\n- Add JWT token validation\n- Implement password hashing\n- Create login endpoint"
                    }
                }]
            })))
        .mount(&mock_server)
        .await;

    let config = AIConfig {
        api_url: mock_server.uri(),
        api_key: "test-key".to_string(),
        model: "gpt-3.5-turbo".to_string(),
        max_tokens: 200,
        temperature: 0.7,
    };

    let ai_service = AIService::new(config);

    let changes = vec![
        FileChange {
            path: "src/auth.rs".to_string(),
            status: FileStatus::Added,
            additions: 45,
            deletions: 0,
        },
        FileChange {
            path: "src/models/user.rs".to_string(),
            status: FileStatus::Modified,
            additions: 15,
            deletions: 3,
        },
    ];

    let suggestions = ai_service.generate_commit_message(&changes).await.unwrap();

    assert!(!suggestions.is_empty());
    assert!(suggestions[0].message.to_lowercase().contains("auth"));
    assert!(suggestions[0].confidence > 0.0);
}
```

## 5. 端到端测试

### 5.1 完整工作流测试

```rust
use ai_commit::App;
use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
use ratatui::backend::TestBackend;
use std::time::Duration;

#[tokio::test]
async fn test_complete_user_workflow() {
    let temp_dir = create_git_repo().await;
    let mut app = App::new(temp_dir.path()).await.unwrap();

    // 模拟按键序列
    let key_sequence = vec![
        // 导航到文件列表
        KeyEvent::new(KeyCode::Tab, KeyModifiers::NONE),
        // 选择文件
        KeyEvent::new(KeyCode::Down, KeyModifiers::NONE),
        KeyEvent::new(KeyCode::Char(' '), KeyModifiers::NONE), // 暂存文件
        // 生成AI提交消息
        KeyEvent::new(KeyCode::Char('a'), KeyModifiers::CONTROL),
        // 确认提交
        KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE),
    ];

    for key_event in key_sequence {
        app.handle_key_event(key_event).await.unwrap();
        tokio::time::sleep(Duration::from_millis(10)).await;
    }

    // 验证结果
    let history = app.git_service.get_commit_history(1).unwrap();
    assert!(!history.is_empty());
    assert!(!history[0].message.is_empty());
}
```

## 6. 性能测试

### 6.3 Agent系统性能测试 (benches/agent_performance.rs)

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ai_commit::{AgentManager, AgentTask, CommitAgent, FileChanges};
use tokio::runtime::Runtime;

fn benchmark_agent_task_dispatch(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function("agent_task_dispatch", |b| {
        b.to_async(&rt).iter(|| async {
            let mut agent_manager = AgentManager::new();
            let agent = CommitAgent::new(AIConfig::benchmark_config()).await.unwrap();
            agent_manager.register_agent(Box::new(agent)).await.unwrap();

            let task = AgentTask::GenerateCommitMessage(FileChanges::new(vec![]));
            let result = agent_manager.dispatch_task(black_box(task)).await;
            black_box(result);
        })
    });
}

fn benchmark_concurrent_agent_execution(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function("concurrent_agent_execution", |b| {
        b.to_async(&rt).iter(|| async {
            let mut agent_manager = AgentManager::new();

            // 注册多个Agent
            for i in 0..5 {
                let agent = CommitAgent::new(AIConfig::benchmark_config()).await.unwrap();
                agent_manager.register_agent(Box::new(agent)).await.unwrap();
            }

            // 并发执行多个任务
            let tasks = (0..10).map(|_| {
                AgentTask::GenerateCommitMessage(FileChanges::new(vec![]))
            }).collect::<Vec<_>>();

            let handles = tasks.into_iter().map(|task| {
                let manager = agent_manager.clone();
                tokio::spawn(async move {
                    manager.dispatch_task(task).await
                })
            }).collect::<Vec<_>>();

            // 等待所有任务完成
            for handle in handles {
                let result = handle.await.unwrap();
                black_box(result);
            }
        })
    });
}

fn benchmark_agent_message_bus(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function("agent_message_bus_throughput", |b| {
        b.to_async(&rt).iter(|| async {
            let (tx, mut rx) = tokio::sync::mpsc::unbounded_channel();
            let message_bus = MessageBus::new(tx);

            // 发送1000条消息
            for i in 0..1000 {
                let message = AgentMessage::TaskAssignment {
                    agent_id: format!("agent_{}", i % 5),
                    task: AgentTask::GenerateCommitMessage(FileChanges::new(vec![])),
                };
                message_bus.send_message(black_box(message)).await.unwrap();
            }

            // 接收所有消息
            let mut count = 0;
            while count < 1000 {
                if rx.recv().await.is_some() {
                    count += 1;
                }
            }
            black_box(count);
        })
    });
}

criterion_group!(
    agent_benches,
    benchmark_agent_task_dispatch,
    benchmark_concurrent_agent_execution,
    benchmark_agent_message_bus
);
```

### 6.4 MCP协议性能测试 (benches/mcp_performance.rs)

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ai_commit::{MCPServer, MCPClient, MCPRequest, RequestId};
use tokio::runtime::Runtime;

fn benchmark_mcp_request_response(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function("mcp_request_response_latency", |b| {
        b.to_async(&rt).iter(|| async {
            let mut server = MCPServer::new(MCPServerConfig {
                port: 0,
                transport: TransportType::Http,
            }).await.unwrap();

            let server_addr = server.start().await.unwrap();

            let client_config = MCPClientConfig {
                server_uri: format!("http://{}", server_addr),
                transport_type: TransportType::Http,
            };

            let mut client = MCPClient::new(client_config).await.unwrap();

            let request = MCPRequest {
                id: RequestId::Number(1),
                method: "ping".to_string(),
                params: None,
            };

            let response = client.send_request(black_box(request)).await;
            black_box(response);

            server.shutdown().await.unwrap();
        })
    });
}

fn benchmark_mcp_concurrent_requests(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    c.bench_function("mcp_concurrent_requests_throughput", |b| {
        b.to_async(&rt).iter(|| async {
            let mut server = MCPServer::new(MCPServerConfig {
                port: 0,
                transport: TransportType::Http,
            }).await.unwrap();

            let server_addr = server.start().await.unwrap();

            let client_config = MCPClientConfig {
                server_uri: format!("http://{}", server_addr),
                transport_type: TransportType::Http,
            };

            let client = Arc::new(MCPClient::new(client_config).await.unwrap());

            // 发送100个并发请求
            let handles = (0..100).map(|i| {
                let client = Arc::clone(&client);
                tokio::spawn(async move {
                    let request = MCPRequest {
                        id: RequestId::Number(i),
                        method: "ping".to_string(),
                        params: None,
                    };
                    client.send_request(request).await
                })
            }).collect::<Vec<_>>();

            // 等待所有请求完成
            for handle in handles {
                let result = handle.await.unwrap();
                black_box(result);
            }

            server.shutdown().await.unwrap();
        })
    });
}

fn benchmark_mcp_websocket_vs_http(c: &mut Criterion) {
    let rt = Runtime::new().unwrap();

    let mut group = c.benchmark_group("mcp_transport_comparison");

    // HTTP传输性能
    group.bench_function("http_transport", |b| {
        b.to_async(&rt).iter(|| async {
            let mut server = MCPServer::new(MCPServerConfig {
                port: 0,
                transport: TransportType::Http,
            }).await.unwrap();

            let server_addr = server.start().await.unwrap();
            let client_config = MCPClientConfig {
                server_uri: format!("http://{}", server_addr),
                transport_type: TransportType::Http,
            };

            let mut client = MCPClient::new(client_config).await.unwrap();

            for i in 0..10 {
                let request = MCPRequest {
                    id: RequestId::Number(i),
                    method: "ping".to_string(),
                    params: None,
                };
                let response = client.send_request(black_box(request)).await;
                black_box(response);
            }

            server.shutdown().await.unwrap();
        })
    });

    // WebSocket传输性能
    group.bench_function("websocket_transport", |b| {
        b.to_async(&rt).iter(|| async {
            let mut server = MCPServer::new(MCPServerConfig {
                port: 0,
                transport: TransportType::WebSocket,
            }).await.unwrap();

            let server_addr = server.start().await.unwrap();
            let client_config = MCPClientConfig {
                server_uri: format!("ws://{}/mcp", server_addr),
                transport_type: TransportType::WebSocket,
            };

            let mut client = MCPClient::new(client_config).await.unwrap();

            for i in 0..10 {
                let request = MCPRequest {
                    id: RequestId::Number(i),
                    method: "ping".to_string(),
                    params: None,
                };
                let response = client.send_request(black_box(request)).await;
                black_box(response);
            }

            server.shutdown().await.unwrap();
        })
    });

    group.finish();
}

criterion_group!(
    mcp_benches,
    benchmark_mcp_request_response,
    benchmark_mcp_concurrent_requests,
    benchmark_mcp_websocket_vs_http
);
### 6.1 基准测试 (benches/git_operations.rs)

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use ai_commit::GitService;
use tempfile::TempDir;

fn benchmark_git_status(c: &mut Criterion) {
    let temp_dir = create_large_git_repo(); // 创建包含大量文件的仓库
    let git_service = GitService::open_repository(temp_dir.path()).unwrap();

    c.bench_function("git_status_large_repo", |b| {
        b.iter(|| {
            let status = git_service.get_status().unwrap();
            black_box(status);
        })
    });
}

fn benchmark_diff_generation(c: &mut Criterion) {
    let temp_dir = create_git_repo_with_large_files();
    let git_service = GitService::open_repository(temp_dir.path()).unwrap();

    c.bench_function("diff_generation_large_file", |b| {
        b.iter(|| {
            let diff = git_service.get_diff("large_file.txt").unwrap();
            black_box(diff);
        })
    });
}

criterion_group!(benches, benchmark_git_status, benchmark_diff_generation);
criterion_main!(benches);
```

## 7. 测试数据管理

### 7.1 测试固件 (tests/fixtures/)

```rust
// tests/fixtures/mod.rs
use std::fs;
use tempfile::TempDir;
use std::process::Command;

pub fn create_simple_git_repo() -> TempDir {
    let temp_dir = TempDir::new().unwrap();
    let repo_path = temp_dir.path();

    // 初始化仓库
    Command::new("git").args(&["init"]).current_dir(repo_path).output().unwrap();

    // 配置用户
    Command::new("git")
        .args(&["config", "user.name", "Test User"])
        .current_dir(repo_path)
        .output()
        .unwrap();

    Command::new("git")
        .args(&["config", "user.email", "test@example.com"])
        .current_dir(repo_path)
        .output()
        .unwrap();

    // 创建初始文件
    fs::write(repo_path.join("README.md"), "# Test Repository").unwrap();

    temp_dir
}

pub fn create_repo_with_history() -> TempDir {
    let temp_dir = create_simple_git_repo();
    let repo_path = temp_dir.path();

    // 创建多个提交
    for i in 1..=5 {
        fs::write(
            repo_path.join(format!("file_{}.txt", i)),
            format!("Content of file {}", i)
        ).unwrap();

        Command::new("git")
            .args(&["add", &format!("file_{}.txt", i)])
            .current_dir(repo_path)
            .output()
            .unwrap();

        Command::new("git")
            .args(&["commit", "-m", &format!("Add file {}", i)])
            .current_dir(repo_path)
            .output()
            .unwrap();
    }

    temp_dir
}
```

## 8. 持续集成测试配置

### 8.1 GitHub Actions配置 (scripts/ci/test.yml)

```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macOS-latest]
        rust: [stable, beta]

    steps:
    - uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: rustfmt, clippy

    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Run tests
      run: cargo test --all-features --verbose

    - name: Run clippy
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: Check formatting
      run: cargo fmt -- --check

    - name: Run integration tests
      run: cargo test --test '*' --all-features

    - name: Run benchmarks
      run: cargo bench --no-run

  coverage:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: llvm-tools-preview

    - name: Install cargo-llvm-cov
      run: cargo install cargo-llvm-cov

    - name: Generate coverage report
      run: cargo llvm-cov --all-features --lcov --output-path lcov.info

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: lcov.info
        fail_ci_if_error: true
```

## 9. 测试最佳实践

### 9.1 测试命名约定
- `test_` + 被测试功能描述
- 使用snake_case命名
- 描述性强的测试名称

### 9.2 测试结构
- Arrange: 准备测试数据
- Act: 执行被测试代码
- Assert: 验证结果

### 9.3 Mock使用原则
- 只mock外部依赖
- 保持mock简单
- 验证mock调用

### 9.4 异步测试
- 使用`#[tokio::test]`
- 适当的超时设置
- 避免竞态条件

## 10. Agent和MCP测试最佳实践

### 10.1 Agent测试策略

**Agent单元测试**:
- 使用Mock trait为Agent依赖创建测试替身
- 测试Agent生命周期的每个阶段
- 验证Agent任务处理的正确性和性能
- 测试Agent错误处理和恢复机制

**Agent集成测试**:
- 测试多Agent协作场景
- 验证Agent间消息传递的可靠性
- 测试Agent负载均衡和故障转移
- 模拟真实的Agent工作负载

### 10.2 MCP协议测试策略

**MCP单元测试**:
- 测试协议消息的序列化和反序列化
- 验证资源和工具的注册和查找
- 测试不同传输层的正确性
- 验证错误处理和协议兼容性

**MCP集成测试**:
- 测试完整的客户端-服务器通信流程
- 验证并发请求的处理能力
- 测试协议升级和向后兼容性
- 模拟网络故障和恢复场景

### 10.3 性能测试指导

**Agent性能测试**:
- 测试Agent任务处理延迟
- 验证消息总线的吞吐量
- 测试并发Agent执行的可扩展性
- 监控Agent内存和CPU使用情况

**MCP性能测试**:
- 比较不同传输层的性能特征
- 测试大量并发连接的处理能力
- 验证协议消息的处理效率
- 测试长连接的稳定性

### 10.4 测试覆盖率要求

**Agent系统**:
- Agent trait实现覆盖率: ≥ 90%
- Agent管理器覆盖率: ≥ 85%
- 消息总线覆盖率: ≥ 95%
- 错误处理路径覆盖率: 100%

**MCP协议**:
- 协议实现覆盖率: ≥ 95%
- 传输层覆盖率: ≥ 85%
- 错误场景覆盖率: 100%
- 协议兼容性测试: 100%

这个测试文档提供了完整的测试策略，特别强化了Agent架构和MCP协议的测试方法，确保AI-Commit TUI项目的代码质量和系统稳定性。