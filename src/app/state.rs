//! Application state management
//!
//! Centralized state management for the entire application following
//! the single source of truth principle.

use chrono::{DateTime, Utc};
use std::collections::HashMap;
use uuid::Uuid;

use crate::{
    ai::AgentResult,
    git::{BranchInfo, CommitInfo, FileStatus, GitService},
    ui::selection::SelectionManager,
};

/// Central application state
///
/// Manages all application state including:
/// - Git repository information
/// - UI state and navigation
/// - Agent tasks and results
/// - Error states and notifications
/// - Performance metrics
#[derive(Debug, Clone)]
pub struct AppState {
    /// Application lifecycle state
    pub app_state: AppLifecycleState,

    /// Git repository state
    pub git_state: GitState,

    /// Git service for repository operations
    pub git_service: Option<GitService>,

    /// UI state
    pub ui_state: UIState,

    /// Agent system state
    pub agent_state: AgentState,

    /// Error and notification state
    pub notification_state: NotificationState,

    /// Performance monitoring state
    pub performance_state: PerformanceState,
}

impl AppState {
    /// Create a new application state
    pub fn new() -> Self {
        Self {
            app_state: AppLifecycleState::default(),
            git_state: GitState::default(),
            git_service: None,
            ui_state: UIState::default(),
            agent_state: AgentState::default(),
            notification_state: NotificationState::default(),
            performance_state: PerformanceState::default(),
        }
    }

    /// Set the Git service
    pub fn set_git_service(&mut self, git_service: GitService) {
        self.git_service = Some(git_service);
        self.git_state.is_repository = true;

        // Initialize with default branch (develop branch as shown in mock data)
        let default_branch = crate::git::BranchInfo {
            name: "develop".to_string(),
            is_current: true,
            is_remote: false,
            upstream: None,
            ahead: 0,
            behind: 0,
            last_commit: "dev1234".to_string(),
            last_commit_message: "Current development work".to_string(),
            last_commit_author: "Developer".to_string(),
            last_commit_date: chrono::Utc::now(),
        };

        // Update current branch and generate initial commits
        let commits = Vec::new(); // Will be auto-generated by update_current_branch
        self.update_current_branch(default_branch, commits);
    }

    /// Check if the application should quit
    pub fn should_quit(&self) -> bool {
        matches!(self.app_state.lifecycle, LifecyclePhase::Quitting)
    }

    /// Set the quit flag
    pub fn set_should_quit(&mut self, should_quit: bool) {
        if should_quit {
            self.app_state.lifecycle = LifecyclePhase::Quitting;
            self.app_state.quit_requested_at = Some(Utc::now());
        }
    }

    /// Update Git status
    pub fn update_git_status(&mut self, status: Vec<FileStatus>) {
        self.git_state.file_status = status;
        self.git_state.last_status_update = Utc::now();
    }

    /// Update agent task result
    pub fn update_agent_result(&mut self, task_id: Uuid, result: AgentResult) {
        self.agent_state.task_results.insert(task_id, result);
    }

    /// Add an error to the notification system
    pub fn add_error(&mut self, error: String) {
        self.notification_state.errors.push(ErrorNotification {
            id: Uuid::new_v4(),
            message: error,
            timestamp: Utc::now(),
            acknowledged: false,
        });
    }

    /// Get current active tab
    pub fn current_tab(&self) -> TabType {
        self.ui_state.current_tab
    }

    /// Set active tab
    pub fn set_current_tab(&mut self, tab: TabType) {
        self.ui_state.current_tab = tab;
        self.ui_state.tab_changed_at = Utc::now();
    }

    /// Update current branch and its commits
    pub fn update_current_branch(&mut self, branch: BranchInfo, mut commits: Vec<CommitInfo>) {
        // If no commits provided, generate mock commits for this branch
        if commits.is_empty() {
            commits = self.generate_mock_commits_for_branch(&branch.name);
        }

        self.git_state.current_branch = Some(branch.clone());
        self.git_state.current_branch_commits = commits.clone();
        self.git_state.commits_by_branch.insert(branch.name.clone(), commits);
        self.git_state.last_commits_update = Utc::now();
    }

    /// Get current branch commits (with caching)
    pub fn get_current_branch_commits(&mut self) -> Vec<CommitInfo> {
        // If we have current branch info but no commits cached, generate mock data
        if let Some(ref branch) = self.git_state.current_branch {
            if self.git_state.current_branch_commits.is_empty() ||
                (Utc::now() - self.git_state.last_commits_update).num_seconds() > 10 {
                let mock_commits = self.generate_mock_commits_for_branch(&branch.name);
                self.git_state.current_branch_commits = mock_commits.clone();
                self.git_state.commits_by_branch.insert(branch.name.clone(), mock_commits);
                self.git_state.last_commits_update = Utc::now();
            }
        }

        self.git_state.current_branch_commits.clone()
    }

    /// Generate mock commits for a specific branch
    fn generate_mock_commits_for_branch(&self, branch_name: &str) -> Vec<CommitInfo> {
        match branch_name {
            "main" => vec![
                CommitInfo {
                    hash: "abc1234567890".to_string(),
                    short_hash: "abc1234".to_string(),
                    message: "feat(main): 主分支的最新功能更新".to_string(),
                    author: "Main Developer".to_string(),
                    author_email: "main@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(1),
                    parents: vec!["def5678".to_string()],
                },
                CommitInfo {
                    hash: "def5678901234".to_string(),
                    short_hash: "def5678".to_string(),
                    message: "fix(main): 修复主分支的关键bug".to_string(),
                    author: "Main Developer".to_string(),
                    author_email: "main@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(3),
                    parents: vec!["ghi9012".to_string()],
                },
                CommitInfo {
                    hash: "ghi9012345678".to_string(),
                    short_hash: "ghi9012".to_string(),
                    message: "chore(main): 更新主分支的依赖包版本".to_string(),
                    author: "Main Developer".to_string(),
                    author_email: "main@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(6),
                    parents: vec!["jkl3456".to_string()],
                },
            ],
            "develop" => vec![
                CommitInfo {
                    hash: "dev1234567890".to_string(),
                    short_hash: "dev1234".to_string(),
                    message: "feat(develop): 开发分支的实验性功能".to_string(),
                    author: "Dev Team".to_string(),
                    author_email: "dev@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::minutes(30),
                    parents: vec!["dev5678".to_string()],
                },
                CommitInfo {
                    hash: "dev5678901234".to_string(),
                    short_hash: "dev5678".to_string(),
                    message: "wip(develop): 正在进行的开发工作".to_string(),
                    author: "Dev Team".to_string(),
                    author_email: "dev@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(2),
                    parents: vec!["dev9012".to_string()],
                },
                CommitInfo {
                    hash: "dev9012345678".to_string(),
                    short_hash: "dev9012".to_string(),
                    message: "test(develop): 添加开发分支的测试用例".to_string(),
                    author: "Dev Team".to_string(),
                    author_email: "dev@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(4),
                    parents: vec!["dev3456".to_string()],
                },
            ],
            _ => vec![
                CommitInfo {
                    hash: "feat123456789".to_string(),
                    short_hash: "feat123".to_string(),
                    message: format!("feat({}): 分支特定的功能实现", branch_name),
                    author: "Feature Developer".to_string(),
                    author_email: "feature@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::minutes(15),
                    parents: vec!["feat567".to_string()],
                },
                CommitInfo {
                    hash: "feat567890123".to_string(),
                    short_hash: "feat567".to_string(),
                    message: format!("fix({}): 修复分支中的问题", branch_name),
                    author: "Feature Developer".to_string(),
                    author_email: "feature@example.com".to_string(),
                    date: Utc::now() - chrono::Duration::hours(1),
                    parents: vec!["feat890".to_string()],
                },
            ]
        }
    }
}

impl Default for AppState {
    fn default() -> Self {
        Self::new()
    }
}

/// Application lifecycle state
#[derive(Debug, Clone)]
pub struct AppLifecycleState {
    pub lifecycle: LifecyclePhase,
    pub started_at: DateTime<Utc>,
    pub quit_requested_at: Option<DateTime<Utc>>,
}

impl Default for AppLifecycleState {
    fn default() -> Self {
        Self {
            lifecycle: LifecyclePhase::Starting,
            started_at: Utc::now(),
            quit_requested_at: None,
        }
    }
}

/// Application lifecycle phases
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LifecyclePhase {
    Starting,
    Running,
    Quitting,
}

/// Git repository state
#[derive(Debug, Clone)]
pub struct GitState {
    pub repository_path: Option<String>,
    pub current_branch: Option<BranchInfo>,
    pub file_status: Vec<FileStatus>,
    pub last_status_update: DateTime<Utc>,
    pub is_repository: bool,
    /// Current branch commits (cached)
    pub current_branch_commits: Vec<CommitInfo>,
    /// Cache of commits by branch name
    pub commits_by_branch: HashMap<String, Vec<CommitInfo>>,
    /// Last commits update time
    pub last_commits_update: DateTime<Utc>,
}

impl Default for GitState {
    fn default() -> Self {
        Self {
            repository_path: None,
            current_branch: None,
            file_status: Vec::new(),
            last_status_update: Utc::now(),
            is_repository: false,
            current_branch_commits: Vec::new(),
            commits_by_branch: HashMap::new(),
            last_commits_update: Utc::now(),
        }
    }
}

/// Focus areas within the UI
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FocusArea {
    Sidebar,    // Branch/Tag/File lists in sidebar
    MainContent,  // Git Log, details, etc. in main content area
}

/// UI state management
#[derive(Debug, Clone)]
pub struct UIState {
    pub current_tab: TabType,
    pub tab_changed_at: DateTime<Utc>,
    pub sidebar_width: u16,
    pub is_sidebar_visible: bool,
    pub terminal_size: (u16, u16),
    pub scroll_offset: usize,
    pub selected_item_index: usize,
    pub current_focus: FocusArea,  // Which area currently has focus
    pub sidebar_selected_index: usize,  // Selected item in sidebar
    pub main_content_selected_index: usize,  // Selected item in main content (e.g., git log)
    pub selection_manager: SelectionManager,  // Text selection and copy functionality
}

impl Default for UIState {
    fn default() -> Self {
        Self {
            current_tab: TabType::Status,
            tab_changed_at: Utc::now(),
            sidebar_width: 25,
            is_sidebar_visible: true,
            terminal_size: (80, 24),
            scroll_offset: 0,
            selected_item_index: 0,
            current_focus: FocusArea::Sidebar,  // Start with sidebar focused
            sidebar_selected_index: 0,
            main_content_selected_index: 0,
            selection_manager: SelectionManager::new(),
        }
    }
}

/// Available UI tabs matching the 6-tab design
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TabType {
    Branches,
    Tags,
    Stash,
    Status,
    Remotes,
    GitFlow,
}

impl TabType {
    /// Get all available tabs
    pub fn all() -> &'static [TabType] {
        &[
            TabType::Branches,
            TabType::Tags,
            TabType::Stash,
            TabType::Status,
            TabType::Remotes,
            TabType::GitFlow,
        ]
    }

    /// Get tab display name
    pub fn name(&self) -> &'static str {
        match self {
            TabType::Branches => "Branches",
            TabType::Tags => "Tags",
            TabType::Stash => "Stash",
            TabType::Status => "Status",
            TabType::Remotes => "Remotes",
            TabType::GitFlow => "Git工作流",
        }
    }
}

/// Agent system state
#[derive(Debug, Clone)]
pub struct AgentState {
    pub active_agents: Vec<String>,
    pub task_results: HashMap<Uuid, AgentResult>,
    pub last_agent_activity: DateTime<Utc>,
}

impl Default for AgentState {
    fn default() -> Self {
        Self {
            active_agents: Vec::new(),
            task_results: HashMap::new(),
            last_agent_activity: Utc::now(),
        }
    }
}

/// Notification state for errors and messages
#[derive(Debug, Clone)]
pub struct NotificationState {
    pub errors: Vec<ErrorNotification>,
    pub info_messages: Vec<InfoNotification>,
}

impl Default for NotificationState {
    fn default() -> Self {
        Self {
            errors: Vec::new(),
            info_messages: Vec::new(),
        }
    }
}

/// Error notification
#[derive(Debug, Clone)]
pub struct ErrorNotification {
    pub id: Uuid,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub acknowledged: bool,
}

/// Info notification
#[derive(Debug, Clone)]
pub struct InfoNotification {
    pub id: Uuid,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub acknowledged: bool,
}

/// Performance monitoring state
#[derive(Debug, Clone)]
pub struct PerformanceState {
    pub startup_time_ms: u64,
    pub last_render_time_ms: u64,
    pub last_git_operation_time_ms: u64,
    pub memory_usage_mb: u64,
    pub performance_warnings: Vec<PerformanceWarning>,
}

impl Default for PerformanceState {
    fn default() -> Self {
        Self {
            startup_time_ms: 0,
            last_render_time_ms: 0,
            last_git_operation_time_ms: 0,
            memory_usage_mb: 0,
            performance_warnings: Vec::new(),
        }
    }
}

/// Performance warning
#[derive(Debug, Clone)]
pub struct PerformanceWarning {
    pub id: Uuid,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub severity: PerformanceWarningSeverity,
}

/// Performance warning severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PerformanceWarningSeverity {
    Low,
    Medium,
    High,
}
